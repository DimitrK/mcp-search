import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { extractWithSpa } from '../../../../../src/core/content/extractors/spaExtractor';

// Mock HTML content that would be rendered by JavaScript
const jsGeneratedContent = `
<!DOCTYPE html>
<html lang="en">
<head>
  <title>SPA Test App</title>
  <meta charset="UTF-8">
</head>
<body>
  <div id="app">Loading...</div>
  <script>
    // Simulate React/Vue app rendering
    document.addEventListener('DOMContentLoaded', function() {
      const app = document.getElementById('app');
      app.innerHTML = \`
        <main>
          <h1>Dynamic Content Title</h1>
          <article>
            <h2>Section 1: JavaScript Rendered Content</h2>
            <p>This comprehensive article content was generated by JavaScript and would not be visible to server-side parsing tools. It demonstrates the sophisticated content extraction capabilities required for modern single-page applications built with React, Vue, Angular, and other JavaScript frameworks.</p>
            <p>Single-page applications present unique challenges for content extraction because their content is dynamically generated after the initial page load. Traditional server-side parsing tools cannot access this content, making browser-based extraction essential for comprehensive content analysis and indexing.</p>
            
            <h2>Section 2: Interactive Elements and Dynamic Features</h2>
            <p>Modern SPAs often contain complex interactive elements that are crucial for understanding the complete user experience and content structure. These elements frequently load asynchronously and require sophisticated extraction techniques.</p>
            <div class="dynamic-widget">
              <p>This dynamic widget represents content that loads after page initialization, simulating real-world scenarios where content appears based on user interactions, API calls, or timed events. Such content is essential for comprehensive content extraction and analysis.</p>
            </div>
            
            <h2>Section 3: Content Quality and Extraction Validation</h2>
            <p>This section ensures that our extracted content meets the minimum quality threshold of 500 characters, validating that the SPA extraction process successfully captures meaningful, substantial content rather than just placeholder text or loading indicators.</p>
          </article>

          <aside class="sidebar">
            <h3>Related Links and Navigation</h3>
            <ul>
              <li>Advanced JavaScript Content Extraction</li>
              <li>Single-Page Application Architecture</li>
              <li>Dynamic Content Analysis Tools</li>
            </ul>
          </aside>
        </main>
      \`;
    });
  </script>
</body>
</html>
`;

const malformedSpaHtml = `
<html>
<head><title>Broken SPA</title></head>
<body>
  <div id="root"></div>
  <script>
    // Broken JavaScript that might cause errors
    document.getElementById('root').innerHTML = '<h1>Error Content</h1>';
    throw new Error('Simulated JS error');
  </script>
</body>
</html>
`;

const emptySpaHtml = `
<html>
<head><title>Empty SPA</title></head>
<body>
  <div id="app"></div>
  <script>
    // JavaScript that doesn't actually render anything meaningful
    console.log('App loaded but no content rendered');
  </script>
</body>
</html>
`;

describe('SpaExtractor', () => {
  // Skip all tests if Playwright is not available
  const playwrightAvailable = (() => {
    try {
      require('playwright');
      return true;
    } catch {
      return false;
    }
  })();

  const skipIfNoPlaywright = playwrightAvailable ? test : test.skip;

  skipIfNoPlaywright(
    'extracts JavaScript-rendered content successfully',
    async () => {
      const result = await extractWithSpa(jsGeneratedContent, {
        url: 'https://example.com/spa',
      });

      expect(result).toBeDefined();
      expect(result.title).toBe('SPA Test App');
      expect(result.extractionMethod).toBe('browser');
      expect(result.textContent).toContain('Dynamic Content Title');
      expect(result.textContent).toContain('JavaScript Rendered Content');
      expect(result.textContent).toContain(
        'This comprehensive article content was generated by JavaScript'
      );
      expect(result.textContent).toContain('Interactive Elements and Dynamic Features');
      expect(result.textContent).toContain('This dynamic widget represents content');

      // Should not contain the loading placeholder
      expect(result.textContent).not.toContain('Loading...');

      // Should extract section structure
      expect(result.sectionPaths).toContain('Dynamic Content Title');
      expect(result.sectionPaths).toContain('Section 1: JavaScript Rendered Content');
      expect(result.sectionPaths).toContain('Section 2: Interactive Elements and Dynamic Features');

      // Should detect language
      expect(result.lang).toBe('en');
    },
    30000
  ); // Longer timeout for browser operations

  skipIfNoPlaywright(
    'throws error for insufficient content after JS errors',
    async () => {
      // This test expects an error because the content is insufficient (<500 chars)
      await expect(
        extractWithSpa(malformedSpaHtml, {
          url: 'https://example.com/broken-spa',
        })
      ).rejects.toThrow('SPA extraction produced insufficient content');
    },
    30000
  );

  skipIfNoPlaywright(
    'throws error for empty SPA content',
    async () => {
      // This test expects an error because there's no meaningful content
      await expect(
        extractWithSpa(emptySpaHtml, {
          url: 'https://example.com/empty-spa',
        })
      ).rejects.toThrow('SPA extraction produced insufficient content');
    },
    30000
  );

  skipIfNoPlaywright(
    'throws error for insufficient delayed content',
    async () => {
      const delayedContentHtml = `
      <html>
      <head><title>Delayed Content</title></head>
      <body>
        <div id="app">Loading...</div>
        <script>
          setTimeout(() => {
            document.getElementById('app').innerHTML = '<h1>Delayed Content Loaded</h1><p>This appeared after a delay.</p>';
          }, 2000); // 2 second delay
        </script>
      </body>
      </html>
    `;

      // This test expects an error because the content is too short (<500 chars)
      await expect(
        extractWithSpa(delayedContentHtml, {
          url: 'https://example.com/delayed',
        })
      ).rejects.toThrow('SPA extraction produced insufficient content');
    },
    30000
  );

  skipIfNoPlaywright(
    'throws error after filtering removes too much content',
    async () => {
      const multimediaSpaHtml = `
      <html>
      <head><title>Multimedia SPA</title></head>
      <body>
        <div id="app">Loading...</div>
        <script>
          document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('app').innerHTML = \`
              <h1>Main Content</h1>
              <p>This is the important text content.</p>
              <img src="image.jpg" alt="Image">
              <video controls><source src="video.mp4"></video>
              <audio controls><source src="audio.mp3"></audio>
              <form>
                <input type="text" placeholder="Enter text">
                <button type="submit">Submit</button>
              </form>
              <script>console.log('inline script');</script>
              <p>More important text after multimedia.</p>
            \`;
          });
        </script>
      </body>
      </html>
    `;

      // This test expects an error because after filtering multimedia/forms/scripts,
      // very little text content remains (<500 chars)
      await expect(
        extractWithSpa(multimediaSpaHtml, {
          url: 'https://example.com/multimedia-spa',
        })
      ).rejects.toThrow('SPA extraction produced insufficient content');
    },
    30000
  );

  skipIfNoPlaywright(
    'returns correlation ID when provided',
    async () => {
      const result = await extractWithSpa(jsGeneratedContent, {
        url: 'https://example.com/correlation-test',
        correlationId: 'spa-test-correlation-123',
      });

      expect(result).toBeDefined();
      expect(result.extractionMethod).toBe('browser');
    },
    30000
  );

  skipIfNoPlaywright(
    'throws error when content is insufficient (<500 chars)',
    async () => {
      const insufficientContentHtml = `
      <html>
      <head><title>Short SPA</title></head>
      <body>
        <div id="app">Loading...</div>
        <script>
          document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('app').innerHTML = '<p>Short</p>';
          });
        </script>
      </body>
      </html>
    `;

      await expect(
        extractWithSpa(insufficientContentHtml, {
          url: 'https://example.com/insufficient-content',
        })
      ).rejects.toThrow('SPA extraction produced insufficient content');
    },
    30000
  );

  // Test that always runs - handles both scenarios
  test('throws error when Playwright is not available', async () => {
    if (playwrightAvailable) {
      // If Playwright IS available, extraction should work
      const result = await extractWithSpa(jsGeneratedContent, {
        url: 'https://example.com/available-test',
      });

      expect(result).toBeDefined();
      expect(result.extractionMethod).toBe('browser');
    } else {
      // If Playwright is NOT available, should throw descriptive error
      await expect(
        extractWithSpa(jsGeneratedContent, {
          url: 'https://example.com/unavailable-test',
        })
      ).rejects.toThrow('Playwright is required for SPA content extraction');
    }
  });

  if (!playwrightAvailable) {
    console.warn(
      '⚠️  Playwright not installed. SPA extractor tests will be skipped. Install with: npm install playwright'
    );
  }
});

