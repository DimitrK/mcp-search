import { describe, test, expect, beforeAll, afterAll } from '@jest/globals';
import { extractWithSpa } from '../../../../../src/core/content/extractors/spaExtractor';

// Mock HTML content that would be rendered by JavaScript
const jsGeneratedContent = `
<!DOCTYPE html>
<html lang="en">
<head>
  <title>SPA Test App</title>
  <meta charset="UTF-8">
</head>
<body>
  <div id="app">Loading...</div>
  <script>
    // Simulate React/Vue app rendering
    document.addEventListener('DOMContentLoaded', function() {
      const app = document.getElementById('app');
      app.innerHTML = \`
        <main>
          <h1>Dynamic Content Title</h1>
          <article>
            <h2>Section 1: JavaScript Rendered</h2>
            <p>This content was generated by JavaScript and would not be visible to server-side parsing.</p>
            <p>It represents the kind of dynamic content found in modern SPAs built with React, Vue, Angular, etc.</p>
            
            <h2>Section 2: Interactive Elements</h2>
            <p>SPAs often contain interactive elements that are crucial for content understanding.</p>
            <div class="dynamic-widget">
              <p>Dynamic widget content that loads after page initialization.</p>
            </div>
          </article>
          
          <aside class="sidebar">
            <h3>Related Links</h3>
            <ul>
              <li>Link 1</li>
              <li>Link 2</li>
            </ul>
          </aside>
        </main>
      \`;
    });
  </script>
</body>
</html>
`;

const malformedSpaHtml = `
<html>
<head><title>Broken SPA</title></head>
<body>
  <div id="root"></div>
  <script>
    // Broken JavaScript that might cause errors
    document.getElementById('root').innerHTML = '<h1>Error Content</h1>';
    throw new Error('Simulated JS error');
  </script>
</body>
</html>
`;

const emptySpaHtml = `
<html>
<head><title>Empty SPA</title></head>
<body>
  <div id="app"></div>
  <script>
    // JavaScript that doesn't actually render anything meaningful
    console.log('App loaded but no content rendered');
  </script>
</body>
</html>
`;

describe('SpaExtractor', () => {
  // Skip all tests if Playwright is not available
  const playwrightAvailable = (() => {
    try {
      require('playwright');
      return true;
    } catch {
      return false;
    }
  })();

  const skipIfNoPlaywright = playwrightAvailable ? test : test.skip;

  skipIfNoPlaywright(
    'extracts JavaScript-rendered content successfully',
    async () => {
      const result = await extractWithSpa(jsGeneratedContent, {
        url: 'https://example.com/spa',
      });

      expect(result).toBeDefined();
      expect(result.title).toBe('SPA Test App');
      expect(result.extractionMethod).toBe('browser');
      expect(result.textContent).toContain('Dynamic Content Title');
      expect(result.textContent).toContain('JavaScript Rendered');
      expect(result.textContent).toContain('This content was generated by JavaScript');
      expect(result.textContent).toContain('Interactive Elements');
      expect(result.textContent).toContain('Dynamic widget content');

      // Should not contain the loading placeholder
      expect(result.textContent).not.toContain('Loading...');

      // Should extract section structure
      expect(result.sectionPaths).toContain('Dynamic Content Title');
      expect(result.sectionPaths).toContain('Section 1: JavaScript Rendered');
      expect(result.sectionPaths).toContain('Section 2: Interactive Elements');

      // Should detect language
      expect(result.lang).toBe('en');
    },
    30000
  ); // Longer timeout for browser operations

  skipIfNoPlaywright(
    'handles JavaScript errors gracefully',
    async () => {
      const result = await extractWithSpa(malformedSpaHtml, {
        url: 'https://example.com/broken-spa',
      });

      expect(result).toBeDefined();
      expect(result.title).toBe('Broken SPA');
      expect(result.extractionMethod).toBe('browser');
      // Should still extract what was rendered before the error
      expect(result.textContent).toContain('Error Content');
    },
    30000
  );

  skipIfNoPlaywright(
    'handles empty SPA content',
    async () => {
      const result = await extractWithSpa(emptySpaHtml, {
        url: 'https://example.com/empty-spa',
      });

      expect(result).toBeDefined();
      expect(result.title).toBe('Empty SPA');
      expect(result.extractionMethod).toBe('browser');
      expect(result.textContent.trim()).toBeTruthy(); // Should have some content even if minimal
      expect(result.sectionPaths).toBeDefined();
    },
    30000
  );

  skipIfNoPlaywright(
    'waits for dynamic content to load',
    async () => {
      const delayedContentHtml = `
      <html>
      <head><title>Delayed Content</title></head>
      <body>
        <div id="app">Loading...</div>
        <script>
          setTimeout(() => {
            document.getElementById('app').innerHTML = '<h1>Delayed Content Loaded</h1><p>This appeared after a delay.</p>';
          }, 2000); // 2 second delay
        </script>
      </body>
      </html>
    `;

      const result = await extractWithSpa(delayedContentHtml, {
        url: 'https://example.com/delayed',
      });

      expect(result).toBeDefined();
      expect(result.textContent).toContain('Delayed Content Loaded');
      expect(result.textContent).toContain('This appeared after a delay');
      expect(result.textContent).not.toContain('Loading...');
    },
    30000
  );

  skipIfNoPlaywright(
    'filters out non-textual content in browser context',
    async () => {
      const multimediaSpaintml = `
      <html>
      <head><title>Multimedia SPA</title></head>
      <body>
        <div id="app">Loading...</div>
        <script>
          document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('app').innerHTML = \`
              <h1>Main Content</h1>
              <p>This is the important text content.</p>
              <img src="image.jpg" alt="Image">
              <video controls><source src="video.mp4"></video>
              <audio controls><source src="audio.mp3"></audio>
              <form>
                <input type="text" placeholder="Enter text">
                <button type="submit">Submit</button>
              </form>
              <script>console.log('inline script');</script>
              <p>More important text after multimedia.</p>
            \`;
          });
        </script>
      </body>
      </html>
    `;

      const result = await extractWithSpa(multimediaSpaintml, {
        url: 'https://example.com/multimedia-spa',
      });

      expect(result).toBeDefined();
      expect(result.textContent).toContain('Main Content');
      expect(result.textContent).toContain('important text content');
      expect(result.textContent).toContain('More important text after multimedia');

      // Should not contain multimedia or form content
      expect(result.textContent).not.toContain('Image');
      expect(result.textContent).not.toContain('Enter text');
      expect(result.textContent).not.toContain('Submit');
      expect(result.textContent).not.toContain('console.log');
    },
    30000
  );

  skipIfNoPlaywright(
    'returns correlation ID when provided',
    async () => {
      const result = await extractWithSpa(jsGeneratedContent, {
        url: 'https://example.com/correlation-test',
        correlationId: 'spa-test-correlation-123',
      });

      expect(result).toBeDefined();
      expect(result.extractionMethod).toBe('browser');
    },
    30000
  );

  skipIfNoPlaywright(
    'throws error when content is insufficient (<500 chars)',
    async () => {
      const insufficientContentHtml = `
      <html>
      <head><title>Short SPA</title></head>
      <body>
        <div id="app">Loading...</div>
        <script>
          document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('app').innerHTML = '<p>Short</p>';
          });
        </script>
      </body>
      </html>
    `;

      await expect(
        extractWithSpa(insufficientContentHtml, {
          url: 'https://example.com/insufficient-content',
        })
      ).rejects.toThrow('SPA extraction produced insufficient content');
    },
    30000
  );

  // Test that always runs - handles both scenarios
  test('throws error when Playwright is not available', async () => {
    if (playwrightAvailable) {
      // If Playwright IS available, extraction should work
      const result = await extractWithSpa(jsGeneratedContent, {
        url: 'https://example.com/available-test',
      });

      expect(result).toBeDefined();
      expect(result.extractionMethod).toBe('browser');
    } else {
      // If Playwright is NOT available, should throw descriptive error
      await expect(
        extractWithSpa(jsGeneratedContent, {
          url: 'https://example.com/unavailable-test',
        })
      ).rejects.toThrow('Playwright is required for SPA content extraction');
    }
  });

  if (!playwrightAvailable) {
    console.warn(
      '⚠️  Playwright not installed. SPA extractor tests will be skipped. Install with: npm install playwright'
    );
  }
});
